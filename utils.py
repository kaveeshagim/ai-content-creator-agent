import os
import datetime
import markdown
import json
from xml.etree.ElementTree import Element, SubElement, tostring
from xml.dom.minidom import parseString
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

TOPIC_MEMORY_FILE = "memory/topics.json"

def convert_markdown_to_html(markdown_text, title, slug):
    html_content = markdown.markdown(markdown_text)

    # Load metadata
    meta_description = ""
    seo_tags = []
    metadata_path = os.path.join("metadata", f"{slug}.json")
    if os.path.exists(metadata_path):
        with open(metadata_path, "r", encoding="utf-8") as meta_file:
            try:
                metadata = json.loads(meta_file.read())
                meta_description = metadata.get("meta_description", "")
                seo_tags = metadata.get("seo_tags", [])
            except json.JSONDecodeError:
                pass

    # Themed HTML
    full_html = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>{title}</title>
        <meta name="description" content="{meta_description}">
        <meta name="keywords" content="{','.join(seo_tags)}">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {{
                font-family: 'Segoe UI', sans-serif;
                background-color: #fdfdfd;
                color: #222;
                line-height: 1.6;
                padding: 2rem;
                max-width: 700px;
                margin: auto;
            }}
            h1, h2, h3 {{
                color: #111;
                margin-top: 2rem;
            }}
            code {{
                background-color: #f5f5f5;
                padding: 0.2em 0.4em;
                font-family: Consolas, monospace;
                border-radius: 4px;
            }}
            pre {{
                background: #f3f3f3;
                padding: 1rem;
                overflow-x: auto;
                border-radius: 6px;
            }}
            a {{
                color: #007acc;
                text-decoration: none;
            }}
            a:hover {{
                text-decoration: underline;
            }}
            footer {{
                margin-top: 4rem;
                font-size: 0.9em;
                text-align: center;
                color: #888;
            }}
        </style>
    </head>
    <body>
        <h1>{title}</h1>
        {html_content}
        <footer>
            <p>✨ Generated by the AI Content Creator Agent</p>
        </footer>
    </body>
    </html>
    """

    os.makedirs("docs", exist_ok=True)
    with open(f"docs/{slug}.html", "w", encoding="utf-8") as f:
        f.write(full_html)

    return f"https://kaveeshagim.github.io/ai-content-creator-agent/{slug}.html"


def generate_rss_feed(
    blog_dir="blogs",
    html_dir="docs",
    output="docs/rss.xml",
    site_url="https://kaveeshagim.github.io/ai-content-creator-agent"
):
    rss = Element("rss", {
        "version": "2.0",
        "xmlns:content": "http://purl.org/rss/1.0/modules/content/"
    })

    channel = SubElement(rss, "channel")

    # Feed header
    SubElement(channel, "title").text = "AI Content Creator Blog"
    SubElement(channel, "link").text = site_url
    SubElement(channel, "description").text = "Auto-generated blogs using GPT-4o"

    for filename in os.listdir(blog_dir):
        if filename.endswith(".md"):
            slug = filename[:-3]
            filepath = os.path.join(blog_dir, filename)
            html_link = f"{site_url}/{slug}.html"
            mod_time = datetime.datetime.fromtimestamp(os.path.getmtime(filepath)).strftime("%a, %d %b %Y %H:%M:%S +0530")

            with open(filepath, "r", encoding="utf-8") as f:
                md_content = f.read()

                # Load metadata
                metadata_path = os.path.join("metadata", f"{slug}.json")
                if os.path.exists(metadata_path):
                    with open(metadata_path, "r", encoding="utf-8") as meta_file:
                        try:
                            metadata = json.loads(meta_file.read())
                        except json.JSONDecodeError:
                            metadata = {}
                else:
                    metadata = {}

            title = md_content.splitlines()[0].replace("#", "").strip()
            html_content = markdown.markdown(md_content)

            item = SubElement(channel, "item")
            SubElement(item, "title").text = title
            SubElement(item, "link").text = html_link
            SubElement(item, "pubDate").text = mod_time
            SubElement(item, "guid").text = html_link
            description = metadata.get("meta_description", f"Read full article at {html_link}")
            SubElement(item, "description").text = description
            SubElement(item, "content:encoded").text = f"<![CDATA[{html_content}]]>"
            tags = metadata.get("seo_tags", [])
            for tag in tags:
                SubElement(item, "category").text = tag


    pretty_xml = parseString(tostring(rss)).toprettyxml(indent="  ")
    with open(output, "w", encoding="utf-8") as f:
        f.write(pretty_xml)

    print(f"✅ RSS feed with content saved as {output}")

def load_topic_memory():
    os.makedirs("memory", exist_ok=True) 
    if not os.path.exists(TOPIC_MEMORY_FILE):
        return []
    with open(TOPIC_MEMORY_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def save_topic_memory(topics):
    with open(TOPIC_MEMORY_FILE, "w", encoding="utf-8") as f:
        json.dump(topics, f, indent=2)

def topic_already_exists(slug):
    return slug in load_topic_memory()

def add_topic_to_memory(slug):
    topics = load_topic_memory()
    topics.append(slug)
    save_topic_memory(topics)


def generate_blog_metadata(blog):
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are an SEO assistant. Output JSON only."),
        ("human", "For the following blog, generate:\n"
                  "- 5 SEO tags (lowercase, no #)\n"
                  "- A meta description (max 160 characters)\n\n"
                  f"Blog:\n{blog}")
    ])

    llm = ChatOpenAI()  # Initialize the LLM (ensure your environment is configured with API keys)
    metadata = llm.invoke(prompt.format_messages())
    return metadata.content

def rewrite_topic(original_topic):
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a helpful assistant who rewrites blog topics to avoid duplication."),
        ("human", f"Rewrite the following blog topic to make it unique, catchy, and different:\n\n{original_topic}")
    ])

    llm = ChatOpenAI()
    response = llm.invoke(prompt.format_messages())
    return response.content.strip()